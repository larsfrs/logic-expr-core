(function(){"use strict";var K=new Set(["NOT","AND","OR","XOR","NAND","NOR","IMPLIES","BICONDITIONAL"]),j={"!":{type:"unary",precedence:4,associativity:"right",notation:"prefix",canonical:"NOT"},"~":{type:"unary",precedence:4,associativity:"right",notation:"prefix",canonical:"NOT"},"'":{type:"unary",precedence:4,associativity:"right",notation:"postfix",canonical:"NOT"},"&":{type:"binary",precedence:3,associativity:"left",notation:"infix",canonical:"AND"},"*":{type:"binary",precedence:3,associativity:"left",notation:"infix",canonical:"AND"},"|":{type:"binary",precedence:2,associativity:"left",notation:"infix",canonical:"OR"},"+":{type:"binary",precedence:2,associativity:"left",notation:"infix",canonical:"OR"}},C={"&":(t,a=!1)=>t&&a,"*":(t,a=!1)=>t&&a,"|":(t,a=!1)=>t||a,"+":(t,a=!1)=>t||a,"!":t=>!t,"~":t=>!t,"⊕":(t,a)=>!t&&a||t&&!a,"⇒":(t,a)=>!t||a,"⊼":(t,a)=>!(t&&a),"⊽":(t,a)=>!(t||a),"⇔":(t,a)=>t&&a||!t&&!a},y={canonicalOperators:K,operatorMetadata:j,operatorEval:C},T={"Distributive Law":{light:"lightsteelblue",dark:"midnightblue"},"Idempotency Law":{light:"palegreen",dark:"seagreen"},"DeMorgan's Law":{light:"thistle",dark:"indigo"},"Absorption Law":{light:"peachpuff",dark:"saddlebrown"},"Identity Law":{light:"gray",dark:"darkslategray"},"Complement Law":{light:"steelblue",dark:"royalblue"},"Associativity Law":{light:"green",dark:"darkgreen"},"Commutativity Law":{light:"orchid",dark:"purple"},"Double Negation Law":{light:"darkorange",dark:"chocolate"},"Dominant Law":{light:"dimgray",dark:"black"}},s={marked:!1},A=y.operatorMetadata,D=class{mark=s;root=!1},w=class extends D{constructor(t,a,r=!1,n=s){super(),this.left=t,this.operator=a,this.root=r,this.mark=n}evaluate(t){return C[this.operator](this.left.evaluate(t))}toString(t=0,a=!1,r=!1,n={latex:!1,darkMode:!1}){const f=A[this.operator].precedence||0,e=this.left.toString(f,!1,r,n);let c=`${n.latex&&y.operatorMetadata[this.operator].canonical==="NOT"?"\\neg ":this.operator}${e}`;return n.latex&&this.mark.marked&&(c=`\\colorbox{${T[this.mark.type][n.darkMode?"dark":"light"]}}{$${c}$}`,c=`\\underbrace{${c}}_{\\text{${this.mark.type}}}`),f<t?`(${c})`:c}},v=class extends D{constructor(t,a,r,n=!1,f=s){super(),this.left=t,this.right=a,this.operator=r,this.root=n,this.mark=f}evaluate(t){return C[this.operator](this.left.evaluate(t),this.right.evaluate(t))}toString(t=0,a=!1,r=!1,n={latex:!1,darkMode:!1}){const f=A[this.operator].precedence||0,e=A[this.operator].associativity||"left",l=this.left.toString(f,!1,r,n),c=this.right.toString(f,!0,r,n),i=`${l}${this.operator}${c}`;return f<t||f===t&&e==="left"&&a||f===t&&e==="right"&&!a?`(${i})`:i}},u=class extends D{constructor(t,a=!1,r=s){super(),this.value=t,this.root=a,this.mark=r}evaluate(t){return t[this.value]??!1}toString(t=0,a=!1,r=!1,n={latex:!1,darkMode:!1}){let f=this.value.toString();return n.latex&&this.mark.marked&&(f=`\\colorbox{${T[this.mark.type][n.darkMode?"dark":"light"]}}{$${f}$}`,f=`\\underbrace{${f}}_{\\text{${this.mark.type}}}`),f}},L=t=>/^[a-zA-Z]$/.test(t);function _(t){const a={"(":")",")":"("};return t.split("").map(r=>a[r]||r).join("")}function W(t,a="*",r="!"){let n="";for(let f=0;f<t.length;f++)if(n+=t[f],f<t.length-1){const e=t[f],l=t[f+1];(L(e)&&L(l)||L(e)&&l==="("||e===")"&&(L(l)||l===r)||e===")"&&(l==="("||l===r)||L(e)&&l===r)&&(n+=a)}return n}function O(t,a=[],r="!",n="'",f=t.length*2){if(!q(t))throw new Error("Unbalanced parentheses in expression");let e=[],l=[],c=0,i=0;for(;c<t.length;){let o=t[c];if(o===r){let g=1;for(;c+g<t.length&&t[c+g]===r;)g++;c+=g;let m=t[c];if(a.includes(m))e.push(m+n.repeat(g)),c++;else if(m==="(")l.push(g),e.push("("),c++;else throw new Error(`Invalid expression: ${r} not followed by variable or '('.`)}else if(a.includes(o))e.push(o),c++;else if(o==="(")l.push(0),e.push("("),c++;else if(o===")"){e.push(")");let g=l.pop();g>0&&e.push(n.repeat(g)),c++}else e.push(o),c++;if(i++,i>f)throw new Error("Invalid Expression: maxIterations exceeded in convertPrefixToPostfix")}return e.join("")}function N(t,a=[],r="'",n="!"){let f=_(t.split("").reverse().join(""));const e=O(f,a,r,n);return _(e.split("").reverse().join(""))}function q(t){let a=[];for(let r of t)if(r==="(")a.push(r);else if(r===")"){if(a.length===0)return!1;a.pop()}return a.length===0}function x(t,a,r,n={addAndOperator:!0}){const f=a.operatorMetadata;for(const e of t)if(!r.includes(e)&&!Object.keys(f).includes(e)&&!["(",")"].includes(e))throw new Error(`Invalid character in expression: ${e}`);if(f[t[0]]&&f[t[0]].type==="binary"||f[t[t.length-1]]&&f[t[t.length-1]].type==="binary")throw new Error(`Expression cannot start or end with a binary operator: ${t}`);if(!q(t))throw new Error(`Unbalanced parentheses in expression: ${t}`);if(tt(t,a))throw new Error(`Multiple operators with the same canonical form found in expression: ${t}`);return t=at(t,a,r),n.addAndOperator&&(t=W(t)),t}function tt(t,a){const r=a.operatorMetadata,n={};for(const f of t)if(r[f]){const e=r[f].canonical;if(n[e]||(n[e]=new Set),n[e].add(f),n[e].size>1)return!0}return!1}function at(t,a,r){let n={},f=t;const e=a.operatorMetadata;for(const l of t)if(a.operatorMetadata[l]&&a.operatorMetadata[l].notation==="postfix"){if(n[l])continue;n[l]=!0}for(const l in n)if(e[l].notation==="postfix"){let c=l;const i=e[l].canonical;for(const o in e)if(e[o].canonical===i&&e[o].notation==="prefix"){c=o;break}f=N(f,r,l,c)}return f}var rt=t=>{const a=new Set;for(const r of t)/[a-zA-Z]/.test(r)&&a.add(r);return Array.from(a).sort()};function nt(t,a,r=[]){const n=a.operatorMetadata,f=[],e=[],l=Object.keys(n).map(o=>/[\\^$*+?.()|[\]{}\-]/.test(o)?"\\"+o:o).join(""),c=r.join(""),i=t.match(new RegExp(`([${l}])|([${c}]+)|([()])`,"g"));if(!i)throw new Error("Invalid expression format");for(const o of i)if(o.match(/[a-zA-Z]+/)||o.match(/[0-9]+/))f.push(o);else if(o==="(")e.push(o);else if(o===")"){for(;e.length>0&&e[e.length-1]!=="(";)f.push(e.pop());if(e.length===0||e[e.length-1]!=="(")throw new Error("Mismatched parentheses in expression");e.pop()}else if(l.includes(o)){const g=n[o].precedence,m=n[o].associativity;for(;e.length>0;){const I=e[e.length-1];if(I==="(")break;const J=n[I].precedence;if(!(m==="left"&&g<=J||m==="right"&&g<J))break;f.push(e.pop())}e.push(o)}else throw new Error(`Unknown token in expression: ${o}`);return[...f,...e.reverse()]}function et(t,a){const r=a.operatorMetadata,n=[];for(const f of t){if(!r[f]){n.push(new u(f));continue}if(r[f].type==="binary"){if(n.length<2)throw new Error("Invalid RPN expression: not enough operands for binary operator");const e=n.pop(),l=n.pop();n.push(new v(l,e,f))}else{if(n.length<1)throw new Error("Invalid RPN expression: not enough operands for unary operator");const e=n.pop();n.push(new w(e,f))}}if(n.length!==1)throw new Error("Invalid RPN expression: remaining operands are without operators");return n[0].root=!0,n[0]}function ft(t,a=y,r=rt(t),n={addAndOperator:!0}){const f=x(t,a,r,n),e=nt(f,a,r);return et(e,a)}var h=class extends D{constructor(t,a,r=!1,n=s){super(),this.children=t,this.operator=a,this.root=r,this.mark=n}evaluate(t){return this.children.reduce((a,r)=>C[this.operator](a,r.evaluate(t)),this.children[0].evaluate(t))}toString(t=0,a=!1,r=!1,n={latex:!1,darkMode:!1}){const f=y.operatorMetadata[this.operator].precedence||0,e=this.children.map(i=>i.toString(f,a,r,n));r&&e.sort((i,o)=>i.localeCompare(o));const l=n.latex&&y.operatorMetadata[this.operator].canonical==="MULTIPLY"?"\\cdot ":this.operator;let c=e.join(l);return n.latex&&this.mark.marked&&(c=`\\colorbox{${T[this.mark.type][n.darkMode?"dark":"light"]}}{$${c}$}`,c=`\\underbrace{${c}}_{\\text{${this.mark.type}}}`),f<t?`(${c})`:c}};function E(t){if(t instanceof u)return new u(t.value,t.root,t.mark);if(t instanceof w)return new w(E(t.left),t.operator,t.root,t.mark);if(t instanceof v){const a=E(t.left),r=E(t.right);if(a instanceof h&&a.operator===t.operator)return a.children.push(r),a.root||=t.root,a;if(r instanceof h&&r.operator===t.operator)return r.children.unshift(a),r.root||=t.root,r;{const n=t.root||a.root||r.root;return new h([a,r],t.operator,n,t.mark)}}}function d(t){return t.toString(void 0,void 0,!0,{latex:!1,darkMode:!1})}function k(t){if(t instanceof w)return new w(k(t.left),t.operator,t.root,t.mark);if(t instanceof v)return new v(k(t.left),k(t.right),t.operator,t.root,t.mark);if(t instanceof h)return new h(t.children.map(a=>k(a)),t.operator,t.root,t.mark);if(t instanceof u)return new u(t.value,t.root,t.mark);throw new Error("Unknown ExpressionNode type")}function z(t,a){return t.flatMap(r=>r instanceof h&&r.operator===a?r.children:[r])}function G(t){return t.children=z(t.children,t.operator),t}function U(t,a,r){a&&(a instanceof h?a.children[a.children.indexOf(r)]=t:a instanceof w&&(a.left=t))}function B(t,a,r=null){if(t instanceof w&&t.operator==="!"){if(t.left instanceof w&&t.left.operator==="!")return a&&(t.root&&(t.left.left.root=t.root),t.mark={marked:!0,type:"Double Negation Law"},a.snapshot(t.left.left)),U(t.left.left,r,t),B(t.left.left,a,t);t.left=B(t.left,a,t)}return t}function Q(t,a){return t instanceof w&&t.operator==="!"&&t.left instanceof w&&t.left.operator==="!"?(a&&(t.root&&(t.left.left.root=t.root),t.mark={marked:!0,type:"Double Negation Law"},a.snapshot(t.left.left)),t.left.left):t}function M(t,a="!",r="*",n="+",f,e=null){if(t instanceof u)return t;if(t instanceof w&&t.operator===a)if(t.left instanceof h&&(t.left.operator===n||t.left.operator===r)){const l=t.left.operator===n?r:n;let c=new h(t.left.children.map(i=>new w(i,a)),l);return f&&(t.root&&(c.root=t.root),t.mark={marked:!0,type:"DeMorgan's Law"},f.snapshot(c),U(c,e,t)),c.children=c.children.map(i=>Q(i,f)),M(c,a,r,n,f,t)}else return t.left=M(t.left,a,r,n,f,t),t;if(t instanceof w&&t.operator!==a)return t.left=M(t.left,a,r,n,f,t),Q(t,f);if(t instanceof h)return t.children=t.children.map(l=>M(l,a,r,n,f,t)),G(t)}function S(t,a,r=null){if(t instanceof u)return t;if(t instanceof w)return t.left=S(t.left,a,t),t;if(t instanceof h){const n=new Map,f=[];for(const e of t.children){const l=d(e);n.has(l)?a&&(n.get(l).mark={marked:!0,type:"Idempotency Law"}):(n.set(l,e),f.push(e))}return a&&f.length<t.children.length&&a.snapshot(t),f.length===1?(a&&t.root&&(f[0].root=!0),f[0]):(a&&(t.children=f),t.children=z(f.map(e=>S(e,a,t)),t.operator),t)}}function P(t,a="+",r=new u("0"),n){if(t instanceof u)return t;if(t instanceof w)return t.left=P(t.left,a,r,n),t;if(t instanceof h&&(t.children=t.children.map(f=>P(f,a,r,n)),t.operator===a)){const f=t.children.filter(e=>e instanceof u&&e.value===r.value?(n&&(e.mark={marked:!0,type:"Identity Law"}),!1):!0);if(n&&f.length<t.children.length&&n.snapshot(t),t.children=f,t.children.length===0)return r;if(t.children.length===1)return t.children[0]}return t}function F(t,a="+",r=new u("0"),n){return t instanceof u?t:t instanceof w?(t.left=F(t.left,a,r,n),t):t instanceof h&&(t.children=t.children.map(f=>F(f,a,r,n)),t.operator===a&&t.children.some(e=>e instanceof u&&e.value===r.value))?(n&&(t.mark={marked:!0,type:"Dominant Law"},n.snapshot(t)),r):t}function R(t,a="+",r="!",n=new u("1"),f){if(t instanceof u)return t;if(t instanceof w)return t.left=R(t.left,a,r,n,f),t;if(t instanceof h&&(t.children=t.children.map(e=>R(e,a,r,n,f)),t.operator===a)){const e=new Map;t.children.forEach((l,c)=>{let i;i=l instanceof w&&l.operator===r?d(l.left):d(l),e.has(i)||e.set(i,[[],[]]),l instanceof w&&l.operator===r?e.get(i)[1].push(c):e.get(i)[0].push(c)});for(const[l,[c,i]]of e)if(c.length>0&&i.length>0){const[o,g]=[c[0],i[0]].sort((m,I)=>m-I);f&&(t.children[o].mark={marked:!0,type:"Complement Law"},t.children[g].mark={marked:!0,type:"Complement Law"},f.snapshot(t)),t.children.splice(o,1,n),t.children.splice(g,1,new u("placeholder"))}if(t.children=t.children.filter(l=>!(l instanceof u&&l.value==="placeholder")),t.children.length===1)return t.children[0].root=t.root,t.children[0]}return t}function V(t,a){return t=R(t,"+","!",new u("1"),a),t=R(t,"*","!",new u("0"),a),t=F(t,"+",new u("1"),a),t=F(t,"*",new u("0"),a),t=P(t,"*",new u("1"),a),t=P(t,"+",new u("0"),a),t}function lt(t,a){return t instanceof h&&t.operator==a}function b(t,a="*",r="+",n,f=null){if(t instanceof u)return t;if(t instanceof w)return t.left=b(t.left,a,r,n,t),t;if(t instanceof h){if(t.operator===a){const e=t.children.find(l=>lt(l,r));if(e){let l=[];const c=t.children.filter(o=>o!==e);for(const o of e.children){const g=[...c.map(k),k(o)],m=new h(g,a);l.push(m)}let i=new h(z(l,r),r);return n&&(t.root&&(i.root=t.root),t.mark={marked:!0,type:"Distributive Law"},n.snapshot(i),U(i,f,t)),b(i,a,r,n,t)}}else t.children=t.children.map(e=>b(e,a,r,n,t));return G(t)}}function p(t){t.mark=s,!(t instanceof u)&&(t instanceof w&&p(t.left),t instanceof v&&(p(t.left),p(t.right)),t instanceof h&&t.children.forEach(a=>p(a)))}var ct=class{rootRef;versions;constructor(t){this.rootRef=t,this.versions=[k(t)]}getRoot(){return this.rootRef}snapshot(t){this.versions.push(k(this.rootRef)),p(this.rootRef),t.root===!0&&t!==this.rootRef&&(this.rootRef=t)}getLastVersion(){return this.versions[this.versions.length-1]}hasChanged(t,a){return d(t)!==d(a)}};function $(t,a=new Set){if(t instanceof u)/^[01]$/.test(t.value)||a.add(t.value);else if(t instanceof w)$(t.left,a);else if(t instanceof v)$(t.left,a),$(t.right,a);else if(t instanceof h)for(const r of t.children)$(r,a);return a}function Z(t,a=$(t),r="*",n="+"){function f(e,l){const c=new Set(l);for(const i of e.children)if(i instanceof u)c.delete(i.value);else if(i instanceof w&&i.operator==="!")if(i.left instanceof u)c.delete(i.left.value);else throw new Error(`expandNormalForm: grandChild is a unary node but its child is not a leaf: ${i.toString()}`);else throw new Error(`expandNormalForm: grandChild is neither a leaf nor a negated leaf: ${i.toString()}`);for(const i of c){const o=[];o.push(new u(i)),o.push(new w(new u(i),"!")),e.children.push(new h(o,n))}return e}if(t instanceof u||t instanceof w){const e=new h([t],r);return Z(e,a,r,n)}if(t instanceof h&&t.operator===r)return Z(new h([t],n),a,r,n);if(t instanceof h&&t.operator===n)t.children=t.children.map(e=>e instanceof h?f(e,a):f(new h([e],r),a));else throw new Error(`expandNormalForm: expressionNode is not an n-ary node with operator '${n}'
            at last step: ${t.toString()}`);return t}function X(t,a=$(t),r="*",n="+"){if(!(t instanceof h&&t.operator===n))return t instanceof h&&t.operator===r?X(new h([t],n),a,r,n):t instanceof u?!0:t instanceof w&&t.operator==="!"&&t.left instanceof u;for(const e of t.children){if(!(e instanceof h&&e.operator===r))return!1;var f=new Set;for(const l of e.children)if(l instanceof u)f.add(l.value);else if(l instanceof w&&l.operator==="!")if(l.left instanceof u)f.add(l.left.value);else return!1;else return!1;return it(a,f)}return!0}function it(t,a){if(t.size!==a.size)return!1;for(const r of t)if(!a.has(r))return!1;return!0}function Y(t,a=!0,r=100){a&&(t=E(t));const n=new ct(t);let f=t;for(let e=0;e<r&&(e===0&&(t=B(t,n)),t=M(t,"!","*","+",n),t=S(t,n),t=V(t,n),!!n.hasChanged(f,t));e++)if(f=t,e===r-1)throw new Error(`HARD_LIMIT reached in toNNF, expressionNode: ${t}`);return{expressionNode:t,history:n}}function H(t,a=100){let{expressionNode:r,history:n}=Y(t,!1,a),f=r;for(let e=0;e<a&&(r=b(r,"*","+",n),r=S(r,n),r=V(r,n),!!n.hasChanged(f,r));e++)if(f=r,e===a-1)throw new Error(`HARD_LIMIT reached in toDNF, expressionNode: ${r}`);return{expressionNode:r,history:n}}function ot(t,a=10){let{expressionNode:r,history:n}=H(t);r=Z(r);for(let f=0;f<a&&(r=b(r,"*","+",n),r=S(r,n),r=V(r,n),!X(r));f++)if(f===a-1)throw new Error(`HARD_LIMIT reached in toExpandedDNF, expressionNode: ${r}`);return{expressionNode:r,history:n}}self.onmessage=t=>{const{expr:a,method:r,limit:n}=t.data;try{const f=ft(a,void 0,void 0,{addAndOperator:!0}),e=E(f);let l,c="";switch(r){case"nnf":l=Y(e,!1,n),c="(NNF)";break;case"dnf":l=H(e,n),c="(DNF)";break;case"ednf":l=ot(e,n),c="(expanded DNF)";break;default:throw new Error("Method not implemented, yet.")}const i=l.history.versions.map(g=>g.toString(void 0,void 0,void 0,{latex:!0,darkMode:!0})),o=l.expressionNode.toString(void 0,void 0,void 0,{latex:!0,darkMode:!0});self.postMessage({success:!0,result:{versionsLatex:i,exprLatex:o,resultingForm:c}})}catch(f){self.postMessage({success:!1,error:f.message})}}})();
