(function(){"use strict";var tt=new Set(["NOT","AND","OR","XOR","NAND","NOR","IMPLIES","BICONDITIONAL"]),rt={"!":{type:"unary",precedence:4,associativity:"right",notation:"prefix",canonical:"NOT",latex:"\\neg"},"~":{type:"unary",precedence:4,associativity:"right",notation:"prefix",canonical:"NOT",latex:"\\neg"},"'":{type:"unary",precedence:4,associativity:"right",notation:"postfix",canonical:"NOT",latex:"\\neg"},"&":{type:"binary",precedence:3,associativity:"left",notation:"infix",canonical:"AND",latex:"\\cdot"},"*":{type:"binary",precedence:3,associativity:"left",notation:"infix",canonical:"AND",latex:"\\cdot"},"|":{type:"binary",precedence:2,associativity:"left",notation:"infix",canonical:"OR",latex:"+"},"+":{type:"binary",precedence:2,associativity:"left",notation:"infix",canonical:"OR",latex:"+"}},_={"&":(t,r=!1)=>t&&r,"*":(t,r=!1)=>t&&r,"|":(t,r=!1)=>t||r,"+":(t,r=!1)=>t||r,"!":t=>!t,"~":t=>!t,"⊕":(t,r)=>!t&&r||t&&!r,"⇒":(t,r)=>!t||r,"⊼":(t,r)=>!(t&&r),"⊽":(t,r)=>!(t||r),"⇔":(t,r)=>t&&r||!t&&!r},P={canonicalOperators:tt,operatorMetadata:rt,operatorEval:_},q={"Distributive Law":{light:"lightsteelblue",dark:"#334155"},"Idempotency Law":{light:"palegreen",dark:"#374151"},"DeMorgan's Law":{light:"thistle",dark:"#4b5563"},"Absorption Law":{light:"peachpuff",dark:"#1e293b"},"Identity Law":{light:"gray",dark:"#475569"},"Complement Law":{light:"steelblue",dark:"#0f172a"},"Associativity Law":{light:"green",dark:"#365314"},"Commutativity Law":{light:"orchid",dark:"#7c3aed"},"Double Negation Law":{light:"darkorange",dark:"#78350f"},"Dominant Law":{light:"dimgray",dark:"#be185d"}},y={marked:!1},T={latex:!1,darkMode:!1,omitAndOperator:!1,forceParentheses:!1},j=P.operatorMetadata,z=class{mark=y;root=!1},s=class extends z{constructor(t,r,n=!1,a=y){super(),this.left=t,this.operator=r,this.root=n,this.mark=a}evaluate(t){return _[this.operator](this.left.evaluate(t))}toString(t=0,r=!1,n=!1,a=T){const f=P.operatorMetadata[this.operator],e=j[this.operator].precedence||0,l=this.left.toString(e,!1,n,a);let c=`${a.latex?`${f.latex} `:this.operator}${l}`;return a.latex&&this.mark.marked&&(c=`\\colorbox{${q[this.mark.type][a.darkMode?"dark":"light"]}}{$${c}$}`,c=`\\underbrace{${c}}_{\\text{${this.mark.type}}}`),a.forceParentheses?`(${c})`:e<t?`(${c})`:c}},C=class extends z{constructor(t,r,n,a=!1,f=y){super(),this.left=t,this.right=r,this.operator=n,this.root=a,this.mark=f}evaluate(t){return _[this.operator](this.left.evaluate(t),this.right.evaluate(t))}toString(t=0,r=!1,n=!1,a=T){const f=j[this.operator].precedence||0,e=j[this.operator].associativity||"left",l=this.left.toString(f,!1,n,a),i=this.right.toString(f,!0,n,a),c=`${l}${this.operator}${i}`,o=f<t||f===t&&e==="left"&&r||f===t&&e==="right"&&!r;return a.forceParentheses?`(${c})`:o?`(${c})`:c}},u=class extends z{constructor(t,r=!1,n=y){super(),this.value=t,this.root=r,this.mark=n}evaluate(t){return t[this.value]??!1}toString(t=0,r=!1,n=!1,a=T){let f=this.value.toString();return a.latex&&this.mark.marked&&(f=`\\colorbox{${q[this.mark.type][a.darkMode?"dark":"light"]}}{$${f}$}`,f=`\\underbrace{${f}}_{\\text{${this.mark.type}}}`),f}},D=t=>/^[a-zA-Z]$/.test(t);function J(t){const r={"(":")",")":"("};return t.split("").map(n=>r[n]||n).join("")}function at(t,r="*",n="!"){let a="";for(let f=0;f<t.length;f++)if(a+=t[f],f<t.length-1){const e=t[f],l=t[f+1];(D(e)&&D(l)||D(e)&&l==="("||e===")"&&(D(l)||l===n)||e===")"&&(l==="("||l===n)||D(e)&&l===n)&&(a+=r)}return a}function nt(t,r=[],n="!",a="'",f=t.length*2){if(!K(t))throw new Error("Unbalanced parentheses in expression");let e=[],l=[],i=0,c=0;for(;i<t.length;){let o=t[i];if(o===n){let w=1;for(;i+w<t.length&&t[i+w]===n;)w++;i+=w;let g=t[i];if(r.includes(g))e.push(g+a.repeat(w)),i++;else if(g==="(")l.push(w),e.push("("),i++;else throw new Error(`Invalid expression: ${n} not followed by variable or '('.`)}else if(r.includes(o))e.push(o),i++;else if(o==="(")l.push(0),e.push("("),i++;else if(o===")"){e.push(")");let w=l.pop();w>0&&e.push(a.repeat(w)),i++}else e.push(o),i++;if(c++,c>f)throw new Error("Invalid Expression: maxIterations exceeded in convertPrefixToPostfix")}return e.join("")}function et(t,r=[],n="'",a="!"){let f=J(t.split("").reverse().join(""));const e=nt(f,r,n,a);return J(e.split("").reverse().join(""))}function K(t){let r=[];for(let n of t)if(n==="(")r.push(n);else if(n===")"){if(r.length===0)return!1;r.pop()}return r.length===0}function ft(t,r,n,a={addAndOperator:!0}){const f=r.operatorMetadata;for(const e of t)if(!n.includes(e)&&!Object.keys(f).includes(e)&&!["(",")"].includes(e))throw new Error(`Invalid character in expression: ${e}`);if(f[t[0]]&&f[t[0]].type==="binary"||f[t[t.length-1]]&&f[t[t.length-1]].type==="binary")throw new Error(`Expression cannot start or end with a binary operator: ${t}`);if(!K(t))throw new Error(`Unbalanced parentheses in expression: ${t}`);if(lt(t,r))throw new Error(`Multiple operators with the same canonical form found in expression: ${t}`);return t=ct(t,r,n),a.addAndOperator&&(t=at(t)),t}function lt(t,r){const n=r.operatorMetadata,a={};for(const f of t)if(n[f]){const e=n[f].canonical;if(a[e]||(a[e]=new Set),a[e].add(f),a[e].size>1)return!0}return!1}function ct(t,r,n){let a={},f=t;const e=r.operatorMetadata;for(const l of t)if(r.operatorMetadata[l]&&r.operatorMetadata[l].notation==="postfix"){if(a[l])continue;a[l]=!0}for(const l in a)if(e[l].notation==="postfix"){let i=l;const c=e[l].canonical;for(const o in e)if(e[o].canonical===c&&e[o].notation==="prefix"){i=o;break}f=et(f,n,l,i)}return f}var it=t=>{const r=new Set;for(const n of t)/[a-zA-Z]/.test(n)&&r.add(n);return Array.from(r).sort()};function ot(t,r,n=[]){const a=r.operatorMetadata,f=[],e=[],l=Object.keys(a).map(o=>/[\\^$*+?.()|[\]{}\-]/.test(o)?"\\"+o:o).join(""),i=n.join(""),c=t.match(new RegExp(`([${l}])|([${i}]+)|([()])`,"g"));if(!c)throw new Error("Invalid expression format");for(const o of c)if(o.match(/[a-zA-Z]+/)||o.match(/[0-9]+/))f.push(o);else if(o==="(")e.push(o);else if(o===")"){for(;e.length>0&&e[e.length-1]!=="(";)f.push(e.pop());if(e.length===0||e[e.length-1]!=="(")throw new Error("Mismatched parentheses in expression");e.pop()}else if(l.includes(o)){const w=a[o].precedence,g=a[o].associativity;for(;e.length>0;){const m=e[e.length-1];if(m==="(")break;const M=a[m].precedence;if(!(g==="left"&&w<=M||g==="right"&&w<M))break;f.push(e.pop())}e.push(o)}else throw new Error(`Unknown token in expression: ${o}`);return[...f,...e.reverse()]}function ut(t,r){const n=r.operatorMetadata,a=[];for(const f of t){if(!n[f]){a.push(new u(f));continue}if(n[f].type==="binary"){if(a.length<2)throw new Error("Invalid RPN expression: not enough operands for binary operator");const e=a.pop(),l=a.pop();a.push(new C(l,e,f))}else{if(a.length<1)throw new Error("Invalid RPN expression: not enough operands for unary operator");const e=a.pop();a.push(new s(e,f))}}if(a.length!==1)throw new Error("Invalid RPN expression: remaining operands are without operators");return a[0].root=!0,a[0]}function ht(t,r=P,n=it(t),a={addAndOperator:!0}){const f=ft(t,r,n,a),e=ot(f,r,n);return ut(e,r)}var h=class extends z{constructor(t,r,n=!1,a=y){super(),this.children=t,this.operator=r,this.root=n,this.mark=a}evaluate(t){return this.children.reduce((r,n)=>_[this.operator](r,n.evaluate(t)),this.children[0].evaluate(t))}toString(t=0,r=!1,n=!1,a=T){const f=P.operatorMetadata[this.operator],e=P.operatorMetadata[this.operator].precedence||0,l=this.children.map(o=>o.toString(e,r,n,a));n&&l.sort((o,w)=>o.localeCompare(w));let i="";f.canonical==="AND"&&a.omitAndOperator||(i=a.latex?`${f.latex} `:this.operator);let c=l.join(i);return a.latex&&this.mark.marked&&(c=`\\colorbox{${q[this.mark.type][a.darkMode?"dark":"light"]}}{$${c}$}`,c=`\\underbrace{${c}}_{\\text{${this.mark.type}}}`),a.forceParentheses&&(c=`(${c})`),e<t?`(${c})`:c}};function F(t){if(t instanceof u)return new u(t.value,t.root,t.mark);if(t instanceof s)return new s(F(t.left),t.operator,t.root,t.mark);if(t instanceof C){const r=F(t.left),n=F(t.right);if(r instanceof h&&r.operator===t.operator)return r.children.push(n),r.root||=t.root,r;if(n instanceof h&&n.operator===t.operator)return n.children.unshift(r),n.root||=t.root,n;{const a=t.root||r.root||n.root;return new h([r,n],t.operator,a,t.mark)}}}function $(t){return t.toString(void 0,void 0,!0,T)}function L(t){if(t instanceof s)return new s(L(t.left),t.operator,t.root,t.mark);if(t instanceof C)return new C(L(t.left),L(t.right),t.operator,t.root,t.mark);if(t instanceof h)return new h(t.children.map(r=>L(r)),t.operator,t.root,t.mark);if(t instanceof u)return new u(t.value,t.root,t.mark);throw new Error("Unknown ExpressionNode type")}function b(t,r){return t.flatMap(n=>n instanceof h&&n.operator===r?n.children:[n])}function Y(t){return t.children=b(t.children,t.operator),t}function G(t,r,n){r&&(r instanceof h?r.children[r.children.indexOf(n)]=t:r instanceof s&&(r.left=t))}function wt(t,r){return t instanceof h&&t.operator==r}function E(t,r="*",n="+",a,f=null){if(t instanceof u)return t;if(t instanceof s)return t.left=E(t.left,r,n,a,t),t;if(t instanceof h){if(t.operator===r){const e=t.children.find(l=>wt(l,n));if(e){let l=[];const i=t.children.filter(o=>o!==e);for(const o of e.children){const w=[...i.map(L),L(o)],g=new h(w,r);l.push(g)}let c=new h(b(l,n),n);return a&&(t.root&&(c.root=t.root),t.mark={marked:!0,type:"Distributive Law"},a.snapshot(c),G(c,f,t)),E(c,r,n,a,t)}}else t.children=t.children.map(e=>E(e,r,n,a,t));return Y(t)}}function R(t,r,n=null){return t instanceof s&&t.operator==="!"?t.left instanceof s&&t.left.operator==="!"?(r&&(t.root&&(t.left.left.root=t.root),t.mark={marked:!0,type:"Double Negation Law"},r.snapshot(t.left.left)),G(t.left.left,n,t),R(t.left.left,r,t)):(t.left=R(t.left,r,t),t):t instanceof s?(t.left=R(t.left,r,t),t):t instanceof h?(t.children=b(t.children.map(a=>R(a,r,t)),t.operator),t):(t instanceof u,t)}function W(t,r){return t instanceof s&&t.operator==="!"&&t.left instanceof s&&t.left.operator==="!"?(r&&(t.root&&(t.left.left.root=t.root),t.mark={marked:!0,type:"Double Negation Law"},r.snapshot(t.left.left)),t.left.left):t}function A(t,r="!",n="*",a="+",f,e=null){if(t instanceof u)return t;if(t instanceof s&&t.operator===r)if(t.left instanceof h&&(t.left.operator===a||t.left.operator===n)){const l=t.left.operator===a?n:a;let i=new h(t.left.children.map(c=>new s(c,r)),l);return f&&(t.root&&(i.root=t.root),t.mark={marked:!0,type:"DeMorgan's Law"},f.snapshot(i),G(i,e,t)),i.children=i.children.map(c=>W(c,f)),A(i,r,n,a,f,t)}else return t.left=A(t.left,r,n,a,f,t),t;if(t instanceof s&&t.operator!==r)return t.left=A(t.left,r,n,a,f,t),W(t,f);if(t instanceof h)return t.children=t.children.map(l=>A(l,r,n,a,f,t)),Y(t)}function st(t,r){const n=[],a=f=>{if(f instanceof h&&f.operator===r){const e=[];for(const l of f.children)l instanceof h&&l.operator===r?e.push(...l.children):e.push(l);return e}return[f]};for(const f of t){const e=a(f);if(e.length>1){const l=new Set,i=e.length;for(let c=1;c<(1<<i)-0;c++){if(c===(1<<i)-1)continue;const o=[];for(let g=0;g<i;g++)c&1<<g&&o.push(e[g]);const w=o.length===1?o[0]:new h(o,r);l.add($(w))}n.push(l)}else n.push(new Set)}return n}function gt(t,r,n){const a=new Array(t.length).fill(!1),f=t.length,e=new Map,l=i=>{const c=i.join(","),o=e.get(c);if(o)return o;const w=i.map(M=>t[M]),g=w.length===1?w[0]:new h(w,n),m=$(g);return e.set(c,m),m};for(let i=0;i<f;i++){const c=r[i];if(!c||c.size===0)continue;const o=[];for(let m=0;m<f;m++)m!==i&&o.push(m);const w=o.length;let g=!1;for(let m=1;m<1<<w&&!g;m++){const M=[];for(let Z=0;Z<w;Z++)m&1<<Z&&M.push(o[Z]);const x=l(M);if(c.has(x)){g=!0;break}}a[i]=g}return a}function mt(t,r="+",n="*",a){const f=st(t.children,n),e=gt(t.children,f,r),l=[];for(let i=0;i<t.children.length;i++)e[i]?a&&(t.children[i].mark={marked:!0,type:"Absorption Law"}):l.push(t.children[i]);return l}function v(t,r="+",n="*",a){if(t instanceof u)return t;if(t instanceof s)return t.left=v(t.left,r,n,a),t;if(t instanceof h)if(t.operator===r){const f=mt(t,r,n,a);return a&&f.length<t.children.length&&a.snapshot(t),f.length===1?(a&&t.root&&(f[0].root=!0),f[0]):(a&&(t.children=f),t.children=b(f.map(e=>v(e,r,n,a)),t.operator),t)}else return t.children=b(t.children.map(f=>v(f,r,n,a)),t.operator),t}function S(t,r,n=null){if(t instanceof u)return t;if(t instanceof s)return t.left=S(t.left,r,t),t;if(t instanceof h){const a=new Map,f=[];for(const e of t.children){const l=$(e);a.has(l)?r&&(a.get(l).mark={marked:!0,type:"Idempotency Law"}):(a.set(l,e),f.push(e))}return r&&f.length<t.children.length&&r.snapshot(t),f.length===1?(r&&t.root&&(f[0].root=!0),f[0]):(r&&(t.children=f),t.children=b(f.map(e=>S(e,r,t)),t.operator),t)}}function B(t,r="+",n=new u("0"),a){if(t instanceof u)return t;if(t instanceof s)return t.left=B(t.left,r,n,a),t;if(t instanceof h&&(t.children=t.children.map(f=>B(f,r,n,a)),t.operator===r)){const f=t.children.filter(e=>e instanceof u&&e.value===n.value?(a&&(e.mark={marked:!0,type:"Identity Law"}),!1):!0);if(a&&f.length<t.children.length&&a.snapshot(t),t.children=f,t.children.length===0)return n;if(t.children.length===1)return t.children[0]}return t}function U(t,r="+",n=new u("0"),a){return t instanceof u?t:t instanceof s?(t.left=U(t.left,r,n,a),t):t instanceof h&&(t.children=t.children.map(f=>U(f,r,n,a)),t.operator===r&&t.children.some(e=>e instanceof u&&e.value===n.value))?(a&&(t.mark={marked:!0,type:"Dominant Law"},a.snapshot(t)),n):t}function V(t,r="+",n="!",a=new u("1"),f){if(t instanceof u)return t;if(t instanceof s)return t.left=V(t.left,r,n,a,f),t;if(t instanceof h&&(t.children=t.children.map(e=>V(e,r,n,a,f)),t.operator===r)){const e=new Map;t.children.forEach((l,i)=>{let c;c=l instanceof s&&l.operator===n?$(l.left):$(l),e.has(c)||e.set(c,[[],[]]),l instanceof s&&l.operator===n?e.get(c)[1].push(i):e.get(c)[0].push(i)});for(const[l,[i,c]]of e)if(i.length>0&&c.length>0){const[o,w]=[i[0],c[0]].sort((g,m)=>g-m);f&&(t.children[o].mark={marked:!0,type:"Complement Law"},t.children[w].mark={marked:!0,type:"Complement Law"},f.snapshot(t)),t.children.splice(o,1,a),t.children.splice(w,1,new u("placeholder"))}if(t.children=t.children.filter(l=>!(l instanceof u&&l.value==="placeholder")),t.children.length===1)return t.children[0].root=t.root,t.children[0]}return t}function d(t,r){return t=V(t,"+","!",new u("1"),r),t=V(t,"*","!",new u("0"),r),t=U(t,"+",new u("1"),r),t=U(t,"*",new u("0"),r),t=B(t,"*",new u("1"),r),t=B(t,"+",new u("0"),r),t}function p(t){t.mark=y,!(t instanceof u)&&(t instanceof s&&p(t.left),t instanceof C&&(p(t.left),p(t.right)),t instanceof h&&t.children.forEach(r=>p(r)))}var kt=class{rootRef;versions;STEP_LIMIT;constructor(t,r=100){if(this.rootRef=t,this.versions=[L(t)],r<0)throw new Error(`ExpressionTreeHistory: STEP_LIMIT has to be at least 0, got ${r}`);this.STEP_LIMIT=r}getRoot(){return this.rootRef}snapshot(t){if(this.versions.length>=this.STEP_LIMIT)throw new Error(`ExpressionTreeHistory: STEP_LIMIT of
                ${this.STEP_LIMIT} reached, cannot store more versions in history.`);this.versions.push(L(this.rootRef)),p(this.rootRef),t.root===!0&&t!==this.rootRef&&(this.rootRef=t)}getLastVersion(){return this.versions[this.versions.length-1]}hasChanged(t,r){return $(t)!==$(r)}};function I(t,r=new Set){if(t instanceof u)/^[01]$/.test(t.value)||r.add(t.value);else if(t instanceof s)I(t.left,r);else if(t instanceof C)I(t.left,r),I(t.right,r);else if(t instanceof h)for(const n of t.children)I(n,r);return r}function H(t,r,n="*",a="+"){function f(e,l){const i=new Set(l);for(const c of e.children)if(c instanceof u)i.delete(c.value);else if(c instanceof s&&c.operator==="!")if(c.left instanceof u)i.delete(c.left.value);else throw new Error(`expandNormalForm: grandChild is a unary node but its child is not a leaf: ${c.toString()}`);else throw new Error(`expandNormalForm: grandChild is neither a leaf nor a negated leaf: ${c.toString()}`);for(const c of i){const o=[];o.push(new u(c)),o.push(new s(new u(c),"!")),e.children.push(new h(o,a))}return e}if(t instanceof u||t instanceof s){const e=new h([t],n);return H(e,r,n,a)}if(t instanceof h&&t.operator===n)return H(new h([t],a),r,n,a);if(t instanceof h&&t.operator===a)t.children=t.children.map(e=>e instanceof h?f(e,r):f(new h([e],n),r));else throw new Error(`expandNormalForm: expressionNode is not an n-ary node with operator '${a}'
            at last step: ${t.toString()}`);return t}function Q(t,r=I(t),n="*",a="+"){if(!(t instanceof h&&t.operator===a))return t instanceof h&&t.operator===n?Q(new h([t],a),r,n,a):t instanceof u?!0:t instanceof s&&t.operator==="!"&&t.left instanceof u;for(const e of t.children){if(!(e instanceof h&&e.operator===n))return!1;var f=new Set;for(const l of e.children)if(l instanceof u)f.add(l.value);else if(l instanceof s&&l.operator==="!")if(l.left instanceof u)f.add(l.left.value);else return!1;else return!1;return vt(r,f)}return!0}function vt(t,r){if(t.size!==r.size)return!1;for(const n of t)if(!r.has(n))return!1;return!0}var k=1e3;function X(t,r=!0,n=100){r&&(t=F(t));const a=new kt(t,n);let f=t;for(let e=0;e<k&&(e===0&&(t=R(t,a)),t=A(t,"!","*","+",a),t=S(t,a),t=d(t,a),t=v(t,"*","+",a),t=v(t,"+","*",a),!!a.hasChanged(f,t));e++)if(f=t,e===k-1)throw new Error(`LOOP_LIMIT reached in toNNF, expressionNode: ${t}`);return{expressionNode:t,history:a}}function O(t,r=100){let{expressionNode:n,history:a}=X(t,!1,r),f=n;for(let e=0;e<k&&(n=E(n,"*","+",a),n=S(n,a),n=d(n,a),n=v(n,"*","+",a),n=v(n,"+","*",a),!!a.hasChanged(f,n));e++)if(f=n,e===k-1)throw new Error(`LOOP_LIMIT reached in toDNF, expressionNode: ${n}`);return{expressionNode:n,history:a}}function Lt(t,r=I(t),n=10){let{expressionNode:a,history:f}=O(t,n);a=H(a,r);for(let e=0;e<k&&(a=E(a,"*","+",f),a=S(a,f),a=d(a,f),!Q(a));e++)if(e===k-1)throw new Error(`LOOP_LIMIT reached in toExpandedDNF, expressionNode: ${a}`);return{expressionNode:a,history:f}}function N(t,r=100){let{expressionNode:n,history:a}=X(t,!1,r),f=n;for(let e=0;e<k&&(n=E(n,"+","*",a),n=S(n,a),n=d(n,a),n=v(n,"*","+",a),n=v(n,"+","*",a),!!a.hasChanged(f,n));e++)if(f=n,e===k-1)throw new Error(`LOOP_LIMIT reached in toCNF, expressionNode: ${n}`);return{expressionNode:n,history:a}}function $t(t,r=I(t),n=10){let{expressionNode:a,history:f}=N(t,n);a=H(a,r,"+","*");for(let e=0;e<k&&(a=E(a,"+","*",f),a=S(a,f),a=d(a,f),!Q(a,void 0,"+","*"));e++)if(e===k-1)throw new Error(`LOOP_LIMIT reached in toExpandedCNF, expressionNode: ${a}`);return{expressionNode:a,history:f}}self.onmessage=t=>{const{expr:r,method:n,limit:a,settings:f}=t.data;try{const e=ht(r,void 0,void 0,{addAndOperator:!0}),l=F(e);let i,c="";switch(n){case"nnf":i=X(l,!1,a),c="(NNF)";break;case"dnf":i=O(l,a),c="(DNF)";break;case"ednf":i=Lt(l,void 0,a),c="(expanded DNF)";break;case"cnf":i=N(l,a),c="(CNF)";break;case"ecnf":i=$t(l,void 0,a),c="(expanded CNF)";break;default:throw new Error("Method not implemented, yet.")}const o=i.history.versions.map(g=>g.toString(void 0,void 0,void 0,f)),w=i.expressionNode.toString(void 0,void 0,void 0,f);self.postMessage({success:!0,result:{versionsLatex:o,exprLatex:w,resultingForm:c}})}catch(e){self.postMessage({success:!1,error:e.message})}}})();
