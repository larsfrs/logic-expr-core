(function(){"use strict";var O=new Set(["NOT","AND","OR","XOR","NAND","NOR","IMPLIES","BICONDITIONAL"]),N={"!":{type:"unary",precedence:4,associativity:"right",notation:"prefix",canonical:"NOT"},"~":{type:"unary",precedence:4,associativity:"right",notation:"prefix",canonical:"NOT"},"'":{type:"unary",precedence:4,associativity:"right",notation:"postfix",canonical:"NOT"},"&":{type:"binary",precedence:3,associativity:"left",notation:"infix",canonical:"AND"},"*":{type:"binary",precedence:3,associativity:"left",notation:"infix",canonical:"AND"},"|":{type:"binary",precedence:2,associativity:"left",notation:"infix",canonical:"OR"},"+":{type:"binary",precedence:2,associativity:"left",notation:"infix",canonical:"OR"}},T={"&":(t,a=!1)=>t&&a,"*":(t,a=!1)=>t&&a,"|":(t,a=!1)=>t||a,"+":(t,a=!1)=>t||a,"!":t=>!t,"~":t=>!t,"⊕":(t,a)=>!t&&a||t&&!a,"⇒":(t,a)=>!t||a,"⊼":(t,a)=>!(t&&a),"⊽":(t,a)=>!(t||a),"⇔":(t,a)=>t&&a||!t&&!a},b={canonicalOperators:O,operatorMetadata:N,operatorEval:T},V={"Distributive Law":{light:"lightsteelblue",dark:"#334155"},"Idempotency Law":{light:"palegreen",dark:"#374151"},"DeMorgan's Law":{light:"thistle",dark:"#4b5563"},"Absorption Law":{light:"peachpuff",dark:"#1e293b"},"Identity Law":{light:"gray",dark:"#475569"},"Complement Law":{light:"steelblue",dark:"#0f172a"},"Associativity Law":{light:"green",dark:"#365314"},"Commutativity Law":{light:"orchid",dark:"#7c3aed"},"Double Negation Law":{light:"darkorange",dark:"#78350f"},"Dominant Law":{light:"dimgray",dark:"#be185d"}},M={marked:!1},Z=b.operatorMetadata,d=class{mark=M;root=!1},w=class extends d{constructor(t,a,n=!1,r=M){super(),this.left=t,this.operator=a,this.root=n,this.mark=r}evaluate(t){return T[this.operator](this.left.evaluate(t))}toString(t=0,a=!1,n=!1,r={latex:!1,darkMode:!1}){const e=Z[this.operator].precedence||0,f=this.left.toString(e,!1,n,r);let c=`${r.latex&&b.operatorMetadata[this.operator].canonical==="NOT"?"\\neg ":this.operator}${f}`;return r.latex&&this.mark.marked&&(c=`\\colorbox{${V[this.mark.type][r.darkMode?"dark":"light"]}}{$${c}$}`,c=`\\underbrace{${c}}_{\\text{${this.mark.type}}}`),e<t?`(${c})`:c}},S=class extends d{constructor(t,a,n,r=!1,e=M){super(),this.left=t,this.right=a,this.operator=n,this.root=r,this.mark=e}evaluate(t){return T[this.operator](this.left.evaluate(t),this.right.evaluate(t))}toString(t=0,a=!1,n=!1,r={latex:!1,darkMode:!1}){const e=Z[this.operator].precedence||0,f=Z[this.operator].associativity||"left",l=this.left.toString(e,!1,n,r),c=this.right.toString(e,!0,n,r),i=`${l}${this.operator}${c}`;return e<t||e===t&&f==="left"&&a||e===t&&f==="right"&&!a?`(${i})`:i}},h=class extends d{constructor(t,a=!1,n=M){super(),this.value=t,this.root=a,this.mark=n}evaluate(t){return t[this.value]??!1}toString(t=0,a=!1,n=!1,r={latex:!1,darkMode:!1}){let e=this.value.toString();return r.latex&&this.mark.marked&&(e=`\\colorbox{${V[this.mark.type][r.darkMode?"dark":"light"]}}{$${e}$}`,e=`\\underbrace{${e}}_{\\text{${this.mark.type}}}`),e}},C=t=>/^[a-zA-Z]$/.test(t);function G(t){const a={"(":")",")":"("};return t.split("").map(n=>a[n]||n).join("")}function x(t,a="*",n="!"){let r="";for(let e=0;e<t.length;e++)if(r+=t[e],e<t.length-1){const f=t[e],l=t[e+1];(C(f)&&C(l)||C(f)&&l==="("||f===")"&&(C(l)||l===n)||f===")"&&(l==="("||l===n)||C(f)&&l===n)&&(r+=a)}return r}function tt(t,a=[],n="!",r="'",e=t.length*2){if(!Q(t))throw new Error("Unbalanced parentheses in expression");let f=[],l=[],c=0,i=0;for(;c<t.length;){let u=t[c];if(u===n){let g=1;for(;c+g<t.length&&t[c+g]===n;)g++;c+=g;let m=t[c];if(a.includes(m))f.push(m+r.repeat(g)),c++;else if(m==="(")l.push(g),f.push("("),c++;else throw new Error(`Invalid expression: ${n} not followed by variable or '('.`)}else if(a.includes(u))f.push(u),c++;else if(u==="(")l.push(0),f.push("("),c++;else if(u===")"){f.push(")");let g=l.pop();g>0&&f.push(r.repeat(g)),c++}else f.push(u),c++;if(i++,i>e)throw new Error("Invalid Expression: maxIterations exceeded in convertPrefixToPostfix")}return f.join("")}function at(t,a=[],n="'",r="!"){let e=G(t.split("").reverse().join(""));const f=tt(e,a,n,r);return G(f.split("").reverse().join(""))}function Q(t){let a=[];for(let n of t)if(n==="(")a.push(n);else if(n===")"){if(a.length===0)return!1;a.pop()}return a.length===0}function rt(t,a,n,r={addAndOperator:!0}){const e=a.operatorMetadata;for(const f of t)if(!n.includes(f)&&!Object.keys(e).includes(f)&&!["(",")"].includes(f))throw new Error(`Invalid character in expression: ${f}`);if(e[t[0]]&&e[t[0]].type==="binary"||e[t[t.length-1]]&&e[t[t.length-1]].type==="binary")throw new Error(`Expression cannot start or end with a binary operator: ${t}`);if(!Q(t))throw new Error(`Unbalanced parentheses in expression: ${t}`);if(nt(t,a))throw new Error(`Multiple operators with the same canonical form found in expression: ${t}`);return t=ft(t,a,n),r.addAndOperator&&(t=x(t)),t}function nt(t,a){const n=a.operatorMetadata,r={};for(const e of t)if(n[e]){const f=n[e].canonical;if(r[f]||(r[f]=new Set),r[f].add(e),r[f].size>1)return!0}return!1}function ft(t,a,n){let r={},e=t;const f=a.operatorMetadata;for(const l of t)if(a.operatorMetadata[l]&&a.operatorMetadata[l].notation==="postfix"){if(r[l])continue;r[l]=!0}for(const l in r)if(f[l].notation==="postfix"){let c=l;const i=f[l].canonical;for(const u in f)if(f[u].canonical===i&&f[u].notation==="prefix"){c=u;break}e=at(e,n,l,c)}return e}var et=t=>{const a=new Set;for(const n of t)/[a-zA-Z]/.test(n)&&a.add(n);return Array.from(a).sort()};function lt(t,a,n=[]){const r=a.operatorMetadata,e=[],f=[],l=Object.keys(r).map(u=>/[\\^$*+?.()|[\]{}\-]/.test(u)?"\\"+u:u).join(""),c=n.join(""),i=t.match(new RegExp(`([${l}])|([${c}]+)|([()])`,"g"));if(!i)throw new Error("Invalid expression format");for(const u of i)if(u.match(/[a-zA-Z]+/)||u.match(/[0-9]+/))e.push(u);else if(u==="(")f.push(u);else if(u===")"){for(;f.length>0&&f[f.length-1]!=="(";)e.push(f.pop());if(f.length===0||f[f.length-1]!=="(")throw new Error("Mismatched parentheses in expression");f.pop()}else if(l.includes(u)){const g=r[u].precedence,m=r[u].associativity;for(;f.length>0;){const s=f[f.length-1];if(s==="(")break;const L=r[s].precedence;if(!(m==="left"&&g<=L||m==="right"&&g<L))break;e.push(f.pop())}f.push(u)}else throw new Error(`Unknown token in expression: ${u}`);return[...e,...f.reverse()]}function ct(t,a){const n=a.operatorMetadata,r=[];for(const e of t){if(!n[e]){r.push(new h(e));continue}if(n[e].type==="binary"){if(r.length<2)throw new Error("Invalid RPN expression: not enough operands for binary operator");const f=r.pop(),l=r.pop();r.push(new S(l,f,e))}else{if(r.length<1)throw new Error("Invalid RPN expression: not enough operands for unary operator");const f=r.pop();r.push(new w(f,e))}}if(r.length!==1)throw new Error("Invalid RPN expression: remaining operands are without operators");return r[0].root=!0,r[0]}function it(t,a=b,n=et(t),r={addAndOperator:!0}){const e=rt(t,a,n,r),f=lt(e,a,n);return ct(f,a)}var o=class extends d{constructor(t,a,n=!1,r=M){super(),this.children=t,this.operator=a,this.root=n,this.mark=r}evaluate(t){return this.children.reduce((a,n)=>T[this.operator](a,n.evaluate(t)),this.children[0].evaluate(t))}toString(t=0,a=!1,n=!1,r={latex:!1,darkMode:!1}){const e=b.operatorMetadata[this.operator].precedence||0,f=this.children.map(i=>i.toString(e,a,n,r));n&&f.sort((i,u)=>i.localeCompare(u));const l=r.latex&&b.operatorMetadata[this.operator].canonical==="MULTIPLY"?"\\cdot ":this.operator;let c=f.join(l);return r.latex&&this.mark.marked&&(c=`\\colorbox{${V[this.mark.type][r.darkMode?"dark":"light"]}}{$${c}$}`,c=`\\underbrace{${c}}_{\\text{${this.mark.type}}}`),e<t?`(${c})`:c}};function D(t){if(t instanceof h)return new h(t.value,t.root,t.mark);if(t instanceof w)return new w(D(t.left),t.operator,t.root,t.mark);if(t instanceof S){const a=D(t.left),n=D(t.right);if(a instanceof o&&a.operator===t.operator)return a.children.push(n),a.root||=t.root,a;if(n instanceof o&&n.operator===t.operator)return n.children.unshift(a),n.root||=t.root,n;{const r=t.root||a.root||n.root;return new o([a,n],t.operator,r,t.mark)}}}function v(t){return t.toString(void 0,void 0,!0,{latex:!1,darkMode:!1})}function k(t){if(t instanceof w)return new w(k(t.left),t.operator,t.root,t.mark);if(t instanceof S)return new S(k(t.left),k(t.right),t.operator,t.root,t.mark);if(t instanceof o)return new o(t.children.map(a=>k(a)),t.operator,t.root,t.mark);if(t instanceof h)return new h(t.value,t.root,t.mark);throw new Error("Unknown ExpressionNode type")}function E(t,a){return t.flatMap(n=>n instanceof o&&n.operator===a?n.children:[n])}function X(t){return t.children=E(t.children,t.operator),t}function _(t,a,n){a&&(a instanceof o?a.children[a.children.indexOf(n)]=t:a instanceof w&&(a.left=t))}function ut(t,a){return t instanceof o&&t.operator==a}function P(t,a="*",n="+",r,e=null){if(t instanceof h)return t;if(t instanceof w)return t.left=P(t.left,a,n,r,t),t;if(t instanceof o){if(t.operator===a){const f=t.children.find(l=>ut(l,n));if(f){let l=[];const c=t.children.filter(u=>u!==f);for(const u of f.children){const g=[...c.map(k),k(u)],m=new o(g,a);l.push(m)}let i=new o(E(l,n),n);return r&&(t.root&&(i.root=t.root),t.mark={marked:!0,type:"Distributive Law"},r.snapshot(i),_(i,e,t)),P(i,a,n,r,t)}}else t.children=t.children.map(f=>P(f,a,n,r,t));return X(t)}}function R(t,a,n=null){return t instanceof w&&t.operator==="!"?t.left instanceof w&&t.left.operator==="!"?(a&&(t.root&&(t.left.left.root=t.root),t.mark={marked:!0,type:"Double Negation Law"},a.snapshot(t.left.left)),_(t.left.left,n,t),R(t.left.left,a,t)):(t.left=R(t.left,a,t),t):t instanceof w?(t.left=R(t.left,a,t),t):t instanceof o?(t.children=E(t.children.map(r=>R(r,a,t)),t.operator),t):(t instanceof h,t)}function Y(t,a){return t instanceof w&&t.operator==="!"&&t.left instanceof w&&t.left.operator==="!"?(a&&(t.root&&(t.left.left.root=t.root),t.mark={marked:!0,type:"Double Negation Law"},a.snapshot(t.left.left)),t.left.left):t}function F(t,a="!",n="*",r="+",e,f=null){if(t instanceof h)return t;if(t instanceof w&&t.operator===a)if(t.left instanceof o&&(t.left.operator===r||t.left.operator===n)){const l=t.left.operator===r?n:r;let c=new o(t.left.children.map(i=>new w(i,a)),l);return e&&(t.root&&(c.root=t.root),t.mark={marked:!0,type:"DeMorgan's Law"},e.snapshot(c),_(c,f,t)),c.children=c.children.map(i=>Y(i,e)),F(c,a,n,r,e,t)}else return t.left=F(t.left,a,n,r,e,t),t;if(t instanceof w&&t.operator!==a)return t.left=F(t.left,a,n,r,e,t),Y(t,e);if(t instanceof o)return t.children=t.children.map(l=>F(l,a,n,r,e,t)),X(t)}function ht(t,a){const n=[],r=e=>{if(e instanceof o&&e.operator===a){const f=[];for(const l of e.children)l instanceof o&&l.operator===a?f.push(...l.children):f.push(l);return f}return[e]};for(const e of t){const f=r(e);if(f.length>1){const l=new Set,c=f.length;for(let i=1;i<(1<<c)-0;i++){if(i===(1<<c)-1)continue;const u=[];for(let m=0;m<c;m++)i&1<<m&&u.push(f[m]);const g=u.length===1?u[0]:new o(u,a);l.add(v(g))}n.push(l)}else n.push(new Set)}return n}function ot(t,a,n){const r=new Array(t.length).fill(!1),e=t.length,f=new Map,l=c=>{const i=c.join(","),u=f.get(i);if(u)return u;const g=c.map(L=>t[L]),m=g.length===1?g[0]:new o(g,n),s=v(m);return f.set(i,s),s};for(let c=0;c<e;c++){const i=a[c];if(!i||i.size===0)continue;const u=[];for(let s=0;s<e;s++)s!==c&&u.push(s);const g=u.length;let m=!1;for(let s=1;s<1<<g&&!m;s++){const L=[];for(let B=0;B<g;B++)s&1<<B&&L.push(u[B]);const W=l(L);if(i.has(W)){m=!0;break}}r[c]=m}return r}function wt(t,a="+",n="*",r){const e=ht(t.children,n),f=ot(t.children,e,a),l=[];for(let c=0;c<t.children.length;c++)f[c]?r&&(t.children[c].mark={marked:!0,type:"Absorption Law"}):l.push(t.children[c]);return l}function $(t,a="+",n="*",r){if(t instanceof h)return t;if(t instanceof w)return t.left=$(t.left,a,n,r),t;if(t instanceof o)if(t.operator===a){const e=wt(t,a,n,r);return r&&e.length<t.children.length&&r.snapshot(t),e.length===1?(r&&t.root&&(e[0].root=!0),e[0]):(r&&(t.children=e),t.children=E(e.map(f=>$(f,a,n,r)),t.operator),t)}else return t.children=E(t.children.map(e=>$(e,a,n,r)),t.operator),t}function I(t,a,n=null){if(t instanceof h)return t;if(t instanceof w)return t.left=I(t.left,a,t),t;if(t instanceof o){const r=new Map,e=[];for(const f of t.children){const l=v(f);r.has(l)?a&&(r.get(l).mark={marked:!0,type:"Idempotency Law"}):(r.set(l,f),e.push(f))}return a&&e.length<t.children.length&&a.snapshot(t),e.length===1?(a&&t.root&&(e[0].root=!0),e[0]):(a&&(t.children=e),t.children=E(e.map(f=>I(f,a,t)),t.operator),t)}}function z(t,a="+",n=new h("0"),r){if(t instanceof h)return t;if(t instanceof w)return t.left=z(t.left,a,n,r),t;if(t instanceof o&&(t.children=t.children.map(e=>z(e,a,n,r)),t.operator===a)){const e=t.children.filter(f=>f instanceof h&&f.value===n.value?(r&&(f.mark={marked:!0,type:"Identity Law"}),!1):!0);if(r&&e.length<t.children.length&&r.snapshot(t),t.children=e,t.children.length===0)return n;if(t.children.length===1)return t.children[0]}return t}function p(t,a="+",n=new h("0"),r){return t instanceof h?t:t instanceof w?(t.left=p(t.left,a,n,r),t):t instanceof o&&(t.children=t.children.map(e=>p(e,a,n,r)),t.operator===a&&t.children.some(f=>f instanceof h&&f.value===n.value))?(r&&(t.mark={marked:!0,type:"Dominant Law"},r.snapshot(t)),n):t}function U(t,a="+",n="!",r=new h("1"),e){if(t instanceof h)return t;if(t instanceof w)return t.left=U(t.left,a,n,r,e),t;if(t instanceof o&&(t.children=t.children.map(f=>U(f,a,n,r,e)),t.operator===a)){const f=new Map;t.children.forEach((l,c)=>{let i;i=l instanceof w&&l.operator===n?v(l.left):v(l),f.has(i)||f.set(i,[[],[]]),l instanceof w&&l.operator===n?f.get(i)[1].push(c):f.get(i)[0].push(c)});for(const[l,[c,i]]of f)if(c.length>0&&i.length>0){const[u,g]=[c[0],i[0]].sort((m,s)=>m-s);e&&(t.children[u].mark={marked:!0,type:"Complement Law"},t.children[g].mark={marked:!0,type:"Complement Law"},e.snapshot(t)),t.children.splice(u,1,r),t.children.splice(g,1,new h("placeholder"))}if(t.children=t.children.filter(l=>!(l instanceof h&&l.value==="placeholder")),t.children.length===1)return t.children[0].root=t.root,t.children[0]}return t}function q(t,a){return t=U(t,"+","!",new h("1"),a),t=U(t,"*","!",new h("0"),a),t=p(t,"+",new h("1"),a),t=p(t,"*",new h("0"),a),t=z(t,"*",new h("1"),a),t=z(t,"+",new h("0"),a),t}function A(t){t.mark=M,!(t instanceof h)&&(t instanceof w&&A(t.left),t instanceof S&&(A(t.left),A(t.right)),t instanceof o&&t.children.forEach(a=>A(a)))}var gt=class{rootRef;versions;constructor(t){this.rootRef=t,this.versions=[k(t)]}getRoot(){return this.rootRef}snapshot(t){this.versions.push(k(this.rootRef)),A(this.rootRef),t.root===!0&&t!==this.rootRef&&(this.rootRef=t)}getLastVersion(){return this.versions[this.versions.length-1]}hasChanged(t,a){return v(t)!==v(a)}};function y(t,a=new Set){if(t instanceof h)/^[01]$/.test(t.value)||a.add(t.value);else if(t instanceof w)y(t.left,a);else if(t instanceof S)y(t.left,a),y(t.right,a);else if(t instanceof o)for(const n of t.children)y(n,a);return a}function j(t,a,n="*",r="+"){function e(f,l){const c=new Set(l);for(const i of f.children)if(i instanceof h)c.delete(i.value);else if(i instanceof w&&i.operator==="!")if(i.left instanceof h)c.delete(i.left.value);else throw new Error(`expandNormalForm: grandChild is a unary node but its child is not a leaf: ${i.toString()}`);else throw new Error(`expandNormalForm: grandChild is neither a leaf nor a negated leaf: ${i.toString()}`);for(const i of c){const u=[];u.push(new h(i)),u.push(new w(new h(i),"!")),f.children.push(new o(u,r))}return f}if(t instanceof h||t instanceof w){const f=new o([t],n);return j(f,a,n,r)}if(t instanceof o&&t.operator===n)return j(new o([t],r),a,n,r);if(t instanceof o&&t.operator===r)t.children=t.children.map(f=>f instanceof o?e(f,a):e(new o([f],n),a));else throw new Error(`expandNormalForm: expressionNode is not an n-ary node with operator '${r}'
            at last step: ${t.toString()}`);return t}function H(t,a=y(t),n="*",r="+"){if(!(t instanceof o&&t.operator===r))return t instanceof o&&t.operator===n?H(new o([t],r),a,n,r):t instanceof h?!0:t instanceof w&&t.operator==="!"&&t.left instanceof h;for(const f of t.children){if(!(f instanceof o&&f.operator===n))return!1;var e=new Set;for(const l of f.children)if(l instanceof h)e.add(l.value);else if(l instanceof w&&l.operator==="!")if(l.left instanceof h)e.add(l.left.value);else return!1;else return!1;return mt(a,e)}return!0}function mt(t,a){if(t.size!==a.size)return!1;for(const n of t)if(!a.has(n))return!1;return!0}function J(t,a=!0,n=100){a&&(t=D(t));const r=new gt(t);let e=t;for(let f=0;f<n&&(f===0&&(t=R(t,r)),t=F(t,"!","*","+",r),t=I(t,r),t=q(t,r),t=$(t,"*","+",r),t=$(t,"+","*",r),!!r.hasChanged(e,t));f++)if(e=t,f===n-1)throw new Error(`HARD_LIMIT reached in toNNF, expressionNode: ${t}`);return{expressionNode:t,history:r}}function K(t,a=100){let{expressionNode:n,history:r}=J(t,!1,a),e=n;for(let f=0;f<a&&(n=P(n,"*","+",r),n=I(n,r),n=q(n,r),n=$(n,"*","+",r),n=$(n,"+","*",r),!!r.hasChanged(e,n));f++)if(e=n,f===a-1)throw new Error(`HARD_LIMIT reached in toDNF, expressionNode: ${n}`);return{expressionNode:n,history:r}}function st(t,a=y(t),n=10){let{expressionNode:r,history:e}=K(t);r=j(r,a);for(let f=0;f<n&&(r=P(r,"*","+",e),r=I(r,e),r=q(r,e),!H(r));f++)if(f===n-1)throw new Error(`HARD_LIMIT reached in toExpandedDNF, expressionNode: ${r}`);return{expressionNode:r,history:e}}self.onmessage=t=>{const{expr:a,method:n,limit:r}=t.data;try{const e=it(a,void 0,void 0,{addAndOperator:!0}),f=D(e);let l,c="";switch(n){case"nnf":l=J(f,!1,r),c="(NNF)";break;case"dnf":l=K(f,r),c="(DNF)";break;case"ednf":l=st(f,void 0,r),c="(expanded DNF)";break;default:throw new Error("Method not implemented, yet.")}const i=l.history.versions.map(g=>g.toString(void 0,void 0,void 0,{latex:!0,darkMode:!0})),u=l.expressionNode.toString(void 0,void 0,void 0,{latex:!0,darkMode:!0});self.postMessage({success:!0,result:{versionsLatex:i,exprLatex:u,resultingForm:c}})}catch(e){self.postMessage({success:!1,error:e.message})}}})();
