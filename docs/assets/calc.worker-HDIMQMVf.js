(function(){"use strict";var K=new Set(["NOT","AND","OR","XOR","NAND","NOR","IMPLIES","BICONDITIONAL"]),j={"!":{type:"unary",precedence:4,associativity:"right",notation:"prefix",canonical:"NOT"},"~":{type:"unary",precedence:4,associativity:"right",notation:"prefix",canonical:"NOT"},"'":{type:"unary",precedence:4,associativity:"right",notation:"postfix",canonical:"NOT"},"&":{type:"binary",precedence:3,associativity:"left",notation:"infix",canonical:"AND"},"*":{type:"binary",precedence:3,associativity:"left",notation:"infix",canonical:"AND"},"|":{type:"binary",precedence:2,associativity:"left",notation:"infix",canonical:"OR"},"+":{type:"binary",precedence:2,associativity:"left",notation:"infix",canonical:"OR"}},P={"&":(t,r=!1)=>t&&r,"*":(t,r=!1)=>t&&r,"|":(t,r=!1)=>t||r,"+":(t,r=!1)=>t||r,"!":t=>!t,"~":t=>!t,"⊕":(t,r)=>!t&&r||t&&!r,"⇒":(t,r)=>!t||r,"⊼":(t,r)=>!(t&&r),"⊽":(t,r)=>!(t||r),"⇔":(t,r)=>t&&r||!t&&!r},E={canonicalOperators:K,operatorMetadata:j,operatorEval:P},v={marked:!1},A=E.operatorMetadata,D=class{mark=v;root=!1},w=class extends D{constructor(t,r,a=!1,n=v){super(),this.left=t,this.operator=r,this.root=a,this.mark=n}evaluate(t){return P[this.operator](this.left.evaluate(t))}toString(t=0,r=!1,a=!1,n={latex:!1}){const f=A[this.operator].precedence||0,e=this.left.toString(f,!1,a,n);let c=`${n.latex&&E.operatorMetadata[this.operator].canonical==="NOT"?"\\neg ":this.operator}${e}`;return n.latex&&this.mark.marked&&(c=`\\colorbox{${this.mark.colorGroup}}{$${c}$}`,c=`\\underbrace{${c}}_{\\text{${this.mark.type}}}`),f<t?`(${c})`:c}},k=class extends D{constructor(t,r,a,n=!1,f=v){super(),this.left=t,this.right=r,this.operator=a,this.root=n,this.mark=f}evaluate(t){return P[this.operator](this.left.evaluate(t),this.right.evaluate(t))}toString(t=0,r=!1,a=!1,n={latex:!1}){const f=A[this.operator].precedence||0,e=A[this.operator].associativity||"left",l=this.left.toString(f,!1,a,n),c=this.right.toString(f,!0,a,n),i=`${l}${this.operator}${c}`;return f<t||f===t&&e==="left"&&r||f===t&&e==="right"&&!r?`(${i})`:i}},u=class extends D{constructor(t,r=!1,a=v){super(),this.value=t,this.root=r,this.mark=a}evaluate(t){return t[this.value]??!1}toString(t=0,r=!1,a=!1,n={latex:!1}){let f=this.value.toString();return n.latex&&this.mark.marked&&(f=`\\colorbox{${this.mark.colorGroup}}{$${f}$}`,f=`\\underbrace{${f}}_{\\text{${this.mark.type}}}`),f}},p=t=>/^[a-zA-Z]$/.test(t);function Z(t){const r={"(":")",")":"("};return t.split("").map(a=>r[a]||a).join("")}function W(t,r="*",a="!"){let n="";for(let f=0;f<t.length;f++)if(n+=t[f],f<t.length-1){const e=t[f],l=t[f+1];(p(e)&&p(l)||p(e)&&l==="("||e===")"&&(p(l)||l===a)||e===")"&&(l==="("||l===a)||p(e)&&l===a)&&(n+=r)}return n}function d(t,r=[],a="!",n="'",f=t.length*2){if(!_(t))throw new Error("Unbalanced parentheses in expression");let e=[],l=[],c=0,i=0;for(;c<t.length;){let o=t[c];if(o===a){let g=1;for(;c+g<t.length&&t[c+g]===a;)g++;c+=g;let m=t[c];if(r.includes(m))e.push(m+n.repeat(g)),c++;else if(m==="(")l.push(g),e.push("("),c++;else throw new Error(`Invalid expression: ${a} not followed by variable or '('.`)}else if(r.includes(o))e.push(o),c++;else if(o==="(")l.push(0),e.push("("),c++;else if(o===")"){e.push(")");let g=l.pop();g>0&&e.push(n.repeat(g)),c++}else e.push(o),c++;if(i++,i>f)throw new Error("Invalid Expression: maxIterations exceeded in convertPrefixToPostfix")}return e.join("")}function O(t,r=[],a="'",n="!"){let f=Z(t.split("").reverse().join(""));const e=d(f,r,a,n);return Z(e.split("").reverse().join(""))}function _(t){let r=[];for(let a of t)if(a==="(")r.push(a);else if(a===")"){if(r.length===0)return!1;r.pop()}return r.length===0}function N(t,r,a,n={addAndOperator:!0}){const f=r.operatorMetadata;for(const e of t)if(!a.includes(e)&&!Object.keys(f).includes(e)&&!["(",")"].includes(e))throw new Error(`Invalid character in expression: ${e}`);if(f[t[0]]&&f[t[0]].type==="binary"||f[t[t.length-1]]&&f[t[t.length-1]].type==="binary")throw new Error(`Expression cannot start or end with a binary operator: ${t}`);if(!_(t))throw new Error(`Unbalanced parentheses in expression: ${t}`);if(x(t,r))throw new Error(`Multiple operators with the same canonical form found in expression: ${t}`);return t=tt(t,r,a),n.addAndOperator&&(t=W(t)),t}function x(t,r){const a=r.operatorMetadata,n={};for(const f of t)if(a[f]){const e=a[f].canonical;if(n[e]||(n[e]=new Set),n[e].add(f),n[e].size>1)return!0}return!1}function tt(t,r,a){let n={},f=t;const e=r.operatorMetadata;for(const l of t)if(r.operatorMetadata[l]&&r.operatorMetadata[l].notation==="postfix"){if(n[l])continue;n[l]=!0}for(const l in n)if(e[l].notation==="postfix"){let c=l;const i=e[l].canonical;for(const o in e)if(e[o].canonical===i&&e[o].notation==="prefix"){c=o;break}f=O(f,a,l,c)}return f}var rt=t=>{const r=new Set;for(const a of t)/[a-zA-Z]/.test(a)&&r.add(a);return Array.from(r).sort()};function at(t,r,a=[]){const n=r.operatorMetadata,f=[],e=[],l=Object.keys(n).map(o=>/[\\^$*+?.()|[\]{}\-]/.test(o)?"\\"+o:o).join(""),c=a.join(""),i=t.match(new RegExp(`([${l}])|([${c}]+)|([()])`,"g"));if(!i)throw new Error("Invalid expression format");for(const o of i)if(o.match(/[a-zA-Z]+/)||o.match(/[0-9]+/))f.push(o);else if(o==="(")e.push(o);else if(o===")"){for(;e.length>0&&e[e.length-1]!=="(";)f.push(e.pop());if(e.length===0||e[e.length-1]!=="(")throw new Error("Mismatched parentheses in expression");e.pop()}else if(l.includes(o)){const g=n[o].precedence,m=n[o].associativity;for(;e.length>0;){const I=e[e.length-1];if(I==="(")break;const J=n[I].precedence;if(!(m==="left"&&g<=J||m==="right"&&g<J))break;f.push(e.pop())}e.push(o)}else throw new Error(`Unknown token in expression: ${o}`);return[...f,...e.reverse()]}function nt(t,r){const a=r.operatorMetadata,n=[];for(const f of t){if(!a[f]){n.push(new u(f));continue}if(a[f].type==="binary"){if(n.length<2)throw new Error("Invalid RPN expression: not enough operands for binary operator");const e=n.pop(),l=n.pop();n.push(new k(l,e,f))}else{if(n.length<1)throw new Error("Invalid RPN expression: not enough operands for unary operator");const e=n.pop();n.push(new w(e,f))}}if(n.length!==1)throw new Error("Invalid RPN expression: remaining operands are without operators");return n[0].root=!0,n[0]}function et(t,r=E,a=rt(t),n={addAndOperator:!0}){const f=N(t,r,a,n),e=at(f,r,a);return nt(e,r)}var h=class extends D{constructor(t,r,a=!1,n=v){super(),this.children=t,this.operator=r,this.root=a,this.mark=n}evaluate(t){return this.children.reduce((r,a)=>P[this.operator](r,a.evaluate(t)),this.children[0].evaluate(t))}toString(t=0,r=!1,a=!1,n={latex:!1}){const f=E.operatorMetadata[this.operator].precedence||0,e=this.children.map(i=>i.toString(f,r,a,n));a&&e.sort((i,o)=>i.localeCompare(o));const l=n.latex&&E.operatorMetadata[this.operator].canonical==="MULTIPLY"?"\\cdot ":this.operator;let c=e.join(l);return n.latex&&this.mark.marked&&(c=`\\colorbox{${this.mark.colorGroup}}{$${c}$}`,c=`\\underbrace{${c}}_{\\text{${this.mark.type}}}`),f<t?`(${c})`:c}};function y(t){if(t instanceof u)return new u(t.value,t.root,t.mark);if(t instanceof w)return new w(y(t.left),t.operator,t.root,t.mark);if(t instanceof k){const r=y(t.left),a=y(t.right);if(r instanceof h&&r.operator===t.operator)return r.children.push(a),r.root||=t.root,r;if(a instanceof h&&a.operator===t.operator)return a.children.unshift(r),a.root||=t.root,a;{const n=t.root||r.root||a.root;return new h([r,a],t.operator,n,t.mark)}}}function S(t){return t.toString(void 0,void 0,!0,{latex:!1})}function s(t){if(t instanceof w)return new w(s(t.left),t.operator,t.root,t.mark);if(t instanceof k)return new k(s(t.left),s(t.right),t.operator,t.root,t.mark);if(t instanceof h)return new h(t.children.map(r=>s(r)),t.operator,t.root,t.mark);if(t instanceof u)return new u(t.value,t.root,t.mark);throw new Error("Unknown ExpressionNode type")}function G(t,r){return t.flatMap(a=>a instanceof h&&a.operator===r?a.children:[a])}function q(t){return t.children=G(t.children,t.operator),t}function z(t,r,a){r&&(r instanceof h?r.children[r.children.indexOf(a)]=t:r instanceof w&&(r.left=t))}function ft(t,r){return t instanceof h&&t.operator==r}function L(t,r="*",a="+",n,f=null){if(t instanceof u)return t;if(t instanceof w)return t.left=L(t.left,r,a,n,t),t;if(t instanceof h){if(t.operator===r){const e=t.children.find(l=>ft(l,a));if(e){let l=[];const c=t.children.filter(o=>o!==e);for(const o of e.children){const g=[...c.map(s),s(o)],m=new h(g,r);l.push(m)}let i=new h(G(l,a),a);return n&&(t.root&&(i.root=t.root),t.mark={marked:!0,type:"Distributive Law",colorGroup:"lightsteelblue"},n.snapshot(i),z(i,f,t)),L(i,r,a,n,t)}}else t.children=t.children.map(e=>L(e,r,a,n,t));return q(t)}}function U(t,r,a=null){if(t instanceof w&&t.operator==="!"){if(t.left instanceof w&&t.left.operator==="!")return r&&(t.root&&(t.left.left.root=t.root),t.mark={marked:!0,type:"Double Negation Law",colorGroup:"lightsteelblue"},r.snapshot(t.left.left)),z(t.left.left,a,t),U(t.left.left,r,t);t.left=U(t.left,r,t)}return t}function Q(t,r){return t instanceof w&&t.operator==="!"&&t.left instanceof w&&t.left.operator==="!"?(r&&(t.root&&(t.left.left.root=t.root),t.mark={marked:!0,type:"Double Negation Law",colorGroup:"lightsteelblue"},r.snapshot(t.left.left)),t.left.left):t}function b(t,r="!",a="*",n="+",f,e=null){if(t instanceof u)return t;if(t instanceof w&&t.operator===r)if(t.left instanceof h&&(t.left.operator===n||t.left.operator===a)){const l=t.left.operator===n?a:n;let c=new h(t.left.children.map(i=>new w(i,r)),l);return f&&(t.root&&(c.root=t.root),t.mark={marked:!0,type:"DeMorgan's Law",colorGroup:"lightsteelblue"},f.snapshot(c),z(c,e,t)),c.children=c.children.map(i=>Q(i,f)),b(c,r,a,n,f,t)}else return t.left=b(t.left,r,a,n,f,t),t;if(t instanceof w&&t.operator!==r)return t.left=b(t.left,r,a,n,f,t),Q(t,f);if(t instanceof h)return t.children=t.children.map(l=>b(l,r,a,n,f,t)),q(t)}function C(t,r,a=null){if(t instanceof u)return t;if(t instanceof w)return t.left=C(t.left,r,t),t;if(t instanceof h){const n=new Map,f=[];for(const e of t.children){const l=S(e);n.has(l)?r&&(n.get(l).mark={marked:!0,type:"Idempotency Law",colorGroup:"thistle"}):(n.set(l,e),f.push(e))}return r&&f.length<t.children.length&&r.snapshot(t),f.length===1?(r&&t.root&&(f[0].root=!0),f[0]):(r&&(t.children=f),t.children=G(f.map(e=>C(e,r,t)),t.operator),t)}}function F(t,r="+",a=new u("0"),n){if(t instanceof u)return t;if(t instanceof w)return t.left=F(t.left,r,a,n),t;if(t instanceof h&&(t.children=t.children.map(f=>F(f,r,a,n)),t.operator===r)){const f=t.children.filter(e=>e instanceof u&&e.value===a.value?(n&&(e.mark={marked:!0,type:"Identity Law",colorGroup:"palegreen"}),!1):!0);if(n&&f.length<t.children.length&&n.snapshot(t),t.children=f,t.children.length===0)return a;if(t.children.length===1)return t.children[0]}return t}function R(t,r="+",a=new u("0"),n){return t instanceof u?t:t instanceof w?(t.left=R(t.left,r,a,n),t):t instanceof h&&(t.children=t.children.map(f=>R(f,r,a,n)),t.operator===r&&t.children.some(e=>e instanceof u&&e.value===a.value))?(n&&(t.mark={marked:!0,type:"Dominant Law",colorGroup:"palegreen"},n.snapshot(t)),a):t}function T(t,r="+",a="!",n=new u("1"),f){if(t instanceof u)return t;if(t instanceof w)return t.left=T(t.left,r,a,n,f),t;if(t instanceof h&&(t.children=t.children.map(e=>T(e,r,a,n,f)),t.operator===r)){const e=new Map;t.children.forEach((l,c)=>{let i;i=l instanceof w&&l.operator===a?S(l.left):S(l),e.has(i)||e.set(i,[[],[]]),l instanceof w&&l.operator===a?e.get(i)[1].push(c):e.get(i)[0].push(c)});for(const[l,[c,i]]of e)if(c.length>0&&i.length>0){const[o,g]=[c[0],i[0]].sort((m,I)=>m-I);f&&(t.children[o].mark={marked:!0,type:"Complement Law",colorGroup:"palegreen"},t.children[g].mark={marked:!0,type:"Complement Law",colorGroup:"palegreen"},f.snapshot(t)),t.children.splice(o,1,n),t.children.splice(g,1,new u("placeholder"))}if(t.children=t.children.filter(l=>!(l instanceof u&&l.value==="placeholder")),t.children.length===1)return t.children[0].root=t.root,t.children[0]}return t}function B(t,r){return t=T(t,"+","!",new u("1"),r),t=T(t,"*","!",new u("0"),r),t=R(t,"+",new u("1"),r),t=R(t,"*",new u("0"),r),t=F(t,"*",new u("1"),r),t=F(t,"+",new u("0"),r),t}function M(t){t.mark=v,!(t instanceof u)&&(t instanceof w&&M(t.left),t instanceof k&&(M(t.left),M(t.right)),t instanceof h&&t.children.forEach(r=>M(r)))}var lt=class{rootRef;versions;constructor(t){this.rootRef=t,this.versions=[s(t)]}getRoot(){return this.rootRef}snapshot(t){this.versions.push(s(this.rootRef)),M(this.rootRef),t.root===!0&&t!==this.rootRef&&(this.rootRef=t)}getLastVersion(){return this.versions[this.versions.length-1]}hasChanged(t,r){return S(t)!==S(r)}};function $(t,r=new Set){if(t instanceof u)/^[01]$/.test(t.value)||r.add(t.value);else if(t instanceof w)$(t.left,r);else if(t instanceof k)$(t.left,r),$(t.right,r);else if(t instanceof h)for(const a of t.children)$(a,r);return r}function V(t,r=$(t),a="*",n="+"){function f(e,l){const c=new Set(l);for(const i of e.children)if(i instanceof u)c.delete(i.value);else if(i instanceof w&&i.operator==="!")if(i.left instanceof u)c.delete(i.left.value);else throw new Error(`expandNormalForm: grandChild is a unary node but its child is not a leaf: ${i.toString()}`);else throw new Error(`expandNormalForm: grandChild is neither a leaf nor a negated leaf: ${i.toString()}`);for(const i of c){const o=[];o.push(new u(i)),o.push(new w(new u(i),"!")),e.children.push(new h(o,n))}return e}if(t instanceof u||t instanceof w){const e=new h([t],a);return V(e,r,a,n)}if(t instanceof h&&t.operator===a)return V(new h([t],n),r,a,n);if(t instanceof h&&t.operator===n)t.children=t.children.map(e=>e instanceof h?f(e,r):f(new h([e],a),r));else throw new Error(`expandNormalForm: expressionNode is not an n-ary node with operator '${n}'
            at last step: ${t.toString()}`);return t}function X(t,r=$(t),a="*",n="+"){if(!(t instanceof h&&t.operator===n))return t instanceof h&&t.operator===a?X(new h([t],n),r,a,n):t instanceof u?!0:t instanceof w&&t.operator==="!"&&t.left instanceof u;for(const e of t.children){if(!(e instanceof h&&e.operator===a))return!1;var f=new Set;for(const l of e.children)if(l instanceof u)f.add(l.value);else if(l instanceof w&&l.operator==="!")if(l.left instanceof u)f.add(l.left.value);else return!1;else return!1;return ct(r,f)}return!0}function ct(t,r){if(t.size!==r.size)return!1;for(const a of t)if(!r.has(a))return!1;return!0}function Y(t,r=!0,a=100){r&&(t=y(t));const n=new lt(t);let f=t;for(let e=0;e<a&&(e===0&&(t=U(t,n)),t=b(t,"!","*","+",n),t=C(t,n),t=B(t,n),!!n.hasChanged(f,t));e++)if(f=t,e===a-1)throw new Error(`HARD_LIMIT reached in toNNF, expressionNode: ${t}`);return{expressionNode:t,history:n}}function H(t,r=100){let{expressionNode:a,history:n}=Y(t,!1,r),f=a;for(let e=0;e<r&&(a=L(a,"*","+",n),a=C(a,n),a=B(a,n),!!n.hasChanged(f,a));e++)if(f=a,e===r-1)throw new Error(`HARD_LIMIT reached in toDNF, expressionNode: ${a}`);return{expressionNode:a,history:n}}function it(t,r=10){let{expressionNode:a,history:n}=H(t);a=V(a);for(let f=0;f<r&&(a=L(a,"*","+",n),a=C(a,n),a=B(a,n),!X(a));f++)if(f===r-1)throw new Error(`HARD_LIMIT reached in toExpandedDNF, expressionNode: ${a}`);return{expressionNode:a,history:n}}self.onmessage=t=>{const{expr:r,method:a,limit:n}=t.data;try{const f=et(r,void 0,void 0,{addAndOperator:!0}),e=y(f);let l,c="";switch(a){case"nnf":l=Y(e,!1,n),c="(NNF)";break;case"dnf":l=H(e,n),c="(DNF)";break;case"ednf":l=it(e,n),c="(expanded DNF)";break;default:throw new Error("Method not implemented, yet.")}const i=l.history.versions.map(g=>g.toString(void 0,void 0,void 0,{latex:!0})),o=l.expressionNode.toString(void 0,void 0,void 0,{latex:!0});self.postMessage({success:!0,result:{versionsLatex:i,exprLatex:o,resultingForm:c}})}catch(f){self.postMessage({success:!1,error:f.message})}}})();
